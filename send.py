#!/usr/bin/env python
from openpyxl import load_workbook
from pdb import set_trace as debug
import re
import os
from bs4 import BeautifulSoup as bs4
import sys
import logging as log
import traceback
os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))
log.basicConfig(filename='mailmerge.log',level=log.INFO)

log.info(os.getcwd())
log.info(os.path.abspath(__name__))

import smtplib
from email.message import EmailMessage

import datetime
from jinja2 import Template
from nameparser import HumanName
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from html2markdown import convert as html2text
from argparse import ArgumentParser

parser = ArgumentParser(description=u"""Send emails based on data in an excel spreadsheet called data.xlsx.  Emails are
sent to the address listed in the 'email' column and data. The email is sent as HTML with a text part autogenerated from
the HTML. Put the HTML in 'template.html. Subject comes from the <title></title> tag in the head of the template.""")

parser.add_argument("-s", "--stylesheet", action="store_true", help="include stylesheet.css in each emails. This may prevent the text part from being automatically generated. ")


ns = parser.parse_args()

if ns.stylesheet:
    try:
        stylesheet = open('stylesheet.css', 'rb').read().decode('utf-8')
    except Exception as e:
        log.info("No stylesheet found.")
        stylesheet = u""
else:
    stylesheet = u""

wb = load_workbook("data.xlsx")
wsname = wb.sheetnames[0]
ws = wb[wsname]
headers = [cell.value for cell in ws[1]]
headers = {header: headers.index(header) for header in headers}


s = smtplib.SMTP('smtp.snl.salk.edu')

def send(To="", From="", Subject="", Html="", Text=""):
    message = MIMEMultipart('alternative')
    message['From'] = From
    message['To'] = To
    message['Subject'] = Subject

    if not Text:
        Text = html2text(Html)

    # Record the MIME types of both parts - text/plain and text/html.
    part1 = MIMEText(Text, 'text')
    part2 = MIMEText(Html, 'html')

    # Attach parts into message container.
    # According to RFC 2046, the last part of a multipart message, in this case
    # the HTML message, is best and preferred.
    message.attach(part1)
    message.attach(part2)

    try:
        s.send_message(message)
        log.info("Emailed {0} -> {1}".format(To, Text))
    except Exception as e:
        log.warning("Failed to send message to {0}".format(To))
        tb = traceback.format_exc()
        print(tb)

    return()

def clean_template(html):
    soup = bs4(html)
    try:
        #Subject might be in the first line of the body.
        Subject = soup.p.text.split("Subject:")[1].strip()
        #Now delete the subject from the template
        soup.p.extract()
    except IndexError:
        #We couldn't find a subject in the template, let's use the name of the parent folder unless it's "mailmerge"
        Subject = os.path.split(os.getcwd())[1]
        if Subject == "mailmerge":
            print("Could not find a Subject. Put a Subject: line as the first line of your template or rename the mailmerge folder to be the subject.")
            sys.exit()

    #Remove meta and style sections of the head
    [meta.extract() for meta in soup('meta')]
    [style.extract() for style in soup('style')]
    htmlTemplate = str(soup)
    return(htmlTemplate, Subject)


htmlTemplate = open("template.html")
htmlTemplate, Subject = clean_template(htmlTemplate)


message_count = 0

rownumber = 1
for row in ws.iter_rows(min_row=2):
    rownumber += 1
    rowDict = {}
    for header in headers:
        rowDict[header] = row[headers[header]].value

    if not rowDict['to'] or not rowDict['from']:
        continue

    skip = str(rowDict.get("skiprow", ""))
    if skip and skip.lower() in ["skip", "yes", "true", "1"]:
        print("skipping row {0}.".format(rownumber))
        continue

    #If the spreadsheet defines a new templatename, then re-render the template. Otherwise, use the old one.
    templatefile = rowDict.get("template")
    if templatefile:
        try:
            htmlTemplate = open(templatefile, 'rb').read()
            htmlTemplate, Subject = clean_template(htmlTemplate)
        except IOError:
            print(u"You have specified a template file {0} that doesn't exist. Exiting...")
            sys.exit(1)


    name = rowDict.get('Name')
    if name:
    #Guess at the first and last name based on the full name. Put them into the dictionary for use in the template.
        try:
            nameparser = HumanName(name)
            rowDict['Firstname'] = nameparser.first
            rowDict['Lastname'] = nameparser.last
        except TypeError: #Occurs when name None.
            pass

    rowDict['stylesheet'] = stylesheet  #Ususally, this does nothing.
    template = Template(htmlTemplate)
    html = template.render(rowDict)

    redirect = rowDict.get('redirect')
    if redirect:
        print("Redirecting {0} to {1}".format(rowDict['to'], redirect))
        rowDict['to'] = redirect

    send(To=rowDict['to'], From=rowDict['from'], Subject=Subject, Html=html)
    logmessage = u"{2} : {1} ==> {0}".format(rowDict['to'], Subject, datetime.datetime.now())
    print(logmessage)
    log.info(logmessage)
    message_count += 1


print("Sent {0} messages".format(message_count))

